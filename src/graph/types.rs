use std::collections::{HashMap, HashSet, VecDeque};

use ndarray::{Array2, Array3};

use crate::structs::cycle::Cycle;
// use crate::structs::cycle_ref;
use crate::structs::vector::{Vector2D, Vector3D};

pub type Adjacency = HashMap<Node, Nodes>;
pub type AdjacencyRef<'a> = HashMap<&'a Vert, HashSet<&'a Vert>>;
pub type AdjC<'a> = [(Node, &'a [Node])];
pub type Bobbins = Vec<Node>;
pub type BobbinsRef<'a> = Vec<VertRef<'a>>;
pub type Count = usize;
pub type Done = HashSet<usize>;
pub type Edge = (Node, Node);
pub type EdgeRef<'a> = (VertRef<'a>, VertRef<'a>);
pub type Edges = HashSet<Edge>;
pub type EdgesRef<'a> = HashSet<VertRef<'a>>;
pub type EdgeAdjacency = HashMap<Edge, HashSet<Edge>>;
pub type Idx = Count;
pub type Idxs = Vec<Idx>;
pub type Loom = Vec<VecDeque<Node>>;
pub type LoomRef<'a> = Vec<VecDeque<VertRef<'a>>>;
pub type Neighbors = HashSet<Node>;
pub type Node = u32;
pub type Nodes = HashSet<Node>;
pub type Point = i32;
pub type Pointi16 = i16;
pub type Points = HashSet<Point>;
pub type Pointsi16 = HashSet<Pointi16>;
pub type Solution = Tour;
pub type Spool = HashMap<u32, Yarn>;
pub type Spooli16 = HashMap<u32, Yarni16>;
pub type Subtours = Vec<Tour>;
pub type SubtoursRef<'a> = Vec<TourRef<'a>>;
pub type Tour = Vec<Node>;
pub type TourRef<'a> = Vec<VertRef<'a>>;
pub type TourSlice<'a> = &'a [Node];
pub type TourSliceRef<'a> = &'a [VertRef<'a>];
pub type Thread = VecDeque<Node>;
pub type ThreadRef<'a> = VecDeque<VertRef<'a>>;
pub type V2d = [Point; 2];
pub type V2Slice<'a> = &'a [V2d];
pub type V3d = [Point; 3];
pub type V3di16 = [i16; 3];
pub type V3Slicei16<'a> = &'a [[i16;3]];
pub type V3Slice<'a> = &'a [V3d];
pub type Vectors2d = Vec<Vector2D>;
pub type Vectors3d = Vec<Vector3D>;
// pub type Vectors3di16 = Vec<Vector3D>;
pub type Vert = (i32, i32, i32);
pub type Verti16 = (i16, i16, i16);
pub type VertRef<'a> = &'a (i32, i32, i32);
pub type Verts = Vec<(i32, i32, i32)>;
pub type Vertsi16 = Vec<Verti16>;
pub type Vert2d = (Point, Point);
pub type Vert2di16 = (Pointi16, Pointi16);
pub type Vert2dd = Vec<Vert2d>;
pub type Vert2ddi16 = Vec<Vert2di16>;
pub type Vert3d = (Point, Point, Point);
pub type Vert3di16 = (Pointi16, Pointi16, Pointi16);
pub type Vert3dd = Vec<Vert3d>;
pub type VertsC2 = [Vert2d];
pub type VertsC2i16 = [Vert2di16];
pub type VertsC3 = [Vert3d];
pub type VertsC3i16 = [Vert3di16];
pub type VertIdx<'a> = HashMap<&'a Vector3D, Node>;
pub type VertIdxRef1<'a> = HashMap<&'a Vert, VertRef<'a>>;
pub type VertIdxRef<'a> = HashMap<(i32, i32, i32), &'a (i32, i32, i32)>;
pub type WarpedLoom<'a> = HashMap<usize, &'a mut Cycle<'a>>;
// pub type WarpedLoomRef<'a> = HashMap<usize, &'a mut cycle_ref::Cycle<'a>>;
pub type Warps = Subtours;
pub type WarpsRef<'a> = Vec<TourRef<'a>>;
pub type Wefts = Loom;
pub type Weights = HashMap<Node, i32>;
pub type Weightsi16 = HashMap<Node, i16>;
pub type WeightsRef<'a> = HashMap<VertRef<'a>, i32>;
pub type Woven = Vec<usize>;
pub type WovenRef<'a> = Vec<usize>;
pub type Yarn = Array2<Point>;
pub type Yarni16 = Array2<i16>;
pub type Yarn3 = Array3<Point>;
pub type ZlevelNodesMap = HashMap<Point, Nodes>;
pub type ZlevelNodesMapi16 = HashMap<Pointi16, Nodes>;
pub type ZOrder = Vec<(Point, usize)>;

